#!/usr/bin/env php
<?php

define('PROJECT_ROOT', realpath(dirname(dirname(__FILE__))));
define('GENERATED_CLASS_DIR', PROJECT_ROOT.'/source/PhysicalQuantity');
define('CONFIG_YAML_PATH', PROJECT_ROOT.'/unitsofmeasure.yml');

require PROJECT_ROOT.'/vendor/autoload.php';

use Symfony\Component\Yaml\Yaml;

$unit_config = load_units_of_measure_definition(CONFIG_YAML_PATH);

print "Clearing target directory ".GENERATED_CLASS_DIR."....\n";
clear_generated_class_directory(GENERATED_CLASS_DIR);

print "Rendering base quantities...\n";
render_class_template($unit_config['base_quantities'], PROJECT_ROOT.'/build/BaseUnitClass.php.tpl');

print "Rendering derived quantities...\n";
render_class_template($unit_config['derived_quantities'], PROJECT_ROOT.'/build/BaseUnitClass.php.tpl');

print "Done.\n";


function load_units_of_measure_definition($file_path) {
    return Yaml::parse(file_get_contents($file_path));
}

function clear_generated_class_directory($path) {
    foreach(array_diff(scandir($path), ['.', '..']) as $file) {
        unlink($path.DIRECTORY_SEPARATOR.$file);
    }
}

function render_class_template($base_units, $template_file_path) {
    foreach($base_units as $data) {
        $data['si_unit'] = normalize_metric_prefixes($data['si_unit']);
        $data = normalize_additional_units($data);

        $data = flag_for_needs_metric_prefixes($data);

        $file_name = GENERATED_CLASS_DIR.'/'.$data['name'].'.php';
        print "    - ".$file_name."\n";

        ob_start();
        require $template_file_path;
        $content = ob_get_contents();
        ob_end_clean();

        file_put_contents($file_name, "<?php\n".$content);
    }
}

function normalize_metric_prefixes($data) {
    if (array_key_exists('metric_prefixes', $data) && !array_key_exists('si_unit_scaling_factor', $data['metric_prefixes'])) {
        $data['metric_prefixes']['si_unit_scaling_factor'] = 1;
    }
    return $data;
}

function normalize_additional_units($data) {
    if (!array_key_exists('additional_units', $data)) {
        $data['additional_units'] = [];
    }

    foreach ($data['additional_units'] as $index => $unit_definition) {
        // If the definition is in string form, we need to parse it
        if (is_string($unit_definition)) {
            list($formula, $units) = explode('=', $unit_definition, 2);
            $units = explode(',', $units);
            $unit_definition = [
                'names'             => array_map('trim', $units),
                'conversion_factor' => trim($formula)
            ];
        }

        // Any variables in formulae like 'x' need to be '$x'
        if (array_key_exists('from_si_unit_formula', $unit_definition)) {
            $unit_definition['from_si_unit_formula'] = preg_replace('/([^\$]*)x/', '${1}$x', $unit_definition['from_si_unit_formula']);
        }
        if (array_key_exists('to_si_unit_formula', $unit_definition)) {
            $unit_definition['to_si_unit_formula'] = preg_replace('/([^\$]*)x/', '${1}$x', $unit_definition['to_si_unit_formula']);
        }

        $unit_definition = normalize_metric_prefixes($unit_definition);

        $data['additional_units'][$index] = $unit_definition;
    }

    return $data;
}

function flag_for_needs_metric_prefixes($data) {
    $data['has_metric_prefixes'] = false;

    // if the si unit has metric prefixes
    if (array_key_exists('metric_prefixes', $data['si_unit'])) {
        $data['has_metric_prefixes'] = true;
    }

    // if any of the unit conversions have metric prefixes
    foreach ($data['additional_units'] as $unit_definition) {
        if (array_key_exists('metric_prefixes', $unit_definition)) {
            $data['has_metric_prefixes'] = true;
            break;
        }
    }

    return $data;
}
